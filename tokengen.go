// Generation of tokens.
package csrf

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"github.com/revel/revel"
	"io"
	"math"
)

var rawTokenLength, lengthCSRFToken int

func randomString(length int) (string, error) {
	buffer := make([]byte, int(math.Ceil(float64(length)/2)))
	if _, err := io.ReadFull(rand.Reader, buffer); err != nil {
		return "", err
	}
	str := hex.EncodeToString(buffer)
	return str[:length], nil
}

// A CSRF token is generated by encoding bytes read from crypto/rand as base64.
func generateNewToken(c *revel.Controller) (token string) {
	token, _ = randomString(rawTokenLength)
	revel.TRACE.Printf("REVEL-CSRF: Generated new Token: '%s' for url %s\n", token, c.Request.URL)
	c.Session[cookieName] = token
	return
}

func init() {
	revel.OnAppStart(func() {
		rawTokenLength = revel.Config.IntDefault("csrf.token.length", 32)
		if rawTokenLength < 32 || rawTokenLength > 512 {
			panic(fmt.Sprintf("REVEL_CSRF: csrf.token.length=%d: expected a length in [32..512]", rawTokenLength))
		}
		lengthCSRFToken = base64.StdEncoding.EncodedLen(rawTokenLength)

		// Check that cryptographically secure PRNG is available.
		_, err := randomString(1)
		if err != nil {
			panic(fmt.Sprintf("REVEL_CSRF: crypto/rand is unavailable: Read() failed with %#v", err))
		}
	})
}
